<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SVG Gallery Viewer</title>
  <style>
    :root {
      --thumb: 180px;
      --gap: 14px;
      --bg: #0b0b0c;
      --fg: #eaeaea;
      --muted:#9aa0a6;
      --sparkle-primary: #7a84ff;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--fg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }

    header {
      position: sticky; top: 0; z-index: 5;
      backdrop-filter: blur(12px) saturate(140%);
      background: color-mix(in oklab, var(--bg) 86%, #000 14% / 82%);
      border-bottom: 1px solid #1f2023;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
    }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 14px 18px; }
    .brand { display: flex; align-items: center; gap: 22px; margin-bottom: 24px; }
    .brand-logo { width: clamp(280px, 40vw, 560px); display: block; padding: 0; border: none; border-radius: 0; box-shadow: none; background: none; }
    .brand-logo img { width: 100%; height: auto; object-fit: contain; display: block; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }

    .controls { display: flex; flex-direction: column; gap: 16px; }
    .control-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 16px;
      width: 100%;
      background: linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
    }
    .control-group {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    .controls .search {
      min-width: 240px;
      max-width: 320px;
      flex-shrink: 0;
    }

    .file-input { display: inline-flex; align-items: center; gap: 10px; }
    input[type="file"] { display: none; }
    .btn { cursor: pointer; padding: 12px 16px; border-radius: 12px; border: 1px solid #2a2b2f; background: #151517; color: var(--fg); transition: .15s ease; position: relative; overflow: hidden; font-weight: 500; min-height: 44px; display: flex; align-items: center; justify-content: center; }
    .btn:hover {
      background: #1b1c1f;
      border-color: #34363b;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .btn.sparkle {
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--sparkle-primary) 78%, #16171c),
        color-mix(in oklab, var(--sparkle-primary) 52%, #0f1016)
      );
      border-color: color-mix(in oklab, var(--sparkle-primary) 32%, #2f3139);
      box-shadow: 0 0 0 rgba(0,0,0,0);
      isolation: isolate;
    }
    .btn.sparkle::before {
      content: '';
      position: absolute;
      inset: -130% 40% 40% -130%;
      background: linear-gradient(120deg,
        transparent,
        color-mix(in srgb, var(--sparkle-primary) 40%, transparent) 48%,
        transparent
      );
      transform: rotate(12deg);
      animation: shimmer 4s linear infinite;
      mix-blend-mode: screen;
    }
    .btn.sparkle:hover {
      border-color: color-mix(in oklab, var(--sparkle-primary) 62%, #ffffff15);
      box-shadow: 0 0 26px color-mix(in srgb, var(--sparkle-primary) 28%, transparent);
    }
    .btn.primary {
      background: linear-gradient(140deg,
        color-mix(in oklab, var(--sparkle-primary) 88%, #545bff),
        color-mix(in oklab, var(--sparkle-primary) 70%, #986eff)
      );
      border-color: color-mix(in oklab, var(--sparkle-primary) 48%, rgba(132, 142, 255, 0.62));
      color: #f6f7ff;
    }
    .btn.primary:hover {
      border-color: color-mix(in oklab, var(--sparkle-primary) 68%, rgba(200, 205, 255, 0.8));
      box-shadow: 0 0 28px color-mix(in srgb, var(--sparkle-primary) 35%, transparent);
    }

    .icon-btn {
      cursor: pointer;
      border: none;
      background: transparent;
      color: var(--muted);
      padding: 6px;
      border-radius: 50%;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .icon-btn:hover { background: rgba(138, 160, 255, 0.12); color: #c6ccff; }

    .toggle {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      border-radius: 999px;
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--sparkle-primary) 18%, #10121a),
        color-mix(in oklab, var(--sparkle-primary) 8%, #14151c)
      );
      border: 1px solid color-mix(in oklab, var(--sparkle-primary) 24%, #2a2b32);
      color: color-mix(in oklab, var(--sparkle-primary) 38%, var(--fg));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      cursor: pointer;
      overflow: hidden;
      min-height: 44px;
      justify-content: center;
    }
    .toggle::before {
      content: '';
      position: absolute;
      inset: -140% 48% 48% -140%;
      background: linear-gradient(120deg,
        transparent,
        color-mix(in srgb, var(--sparkle-primary) 32%, transparent) 45%,
        transparent
      );
      transform: rotate(16deg);
      animation: shimmer 5.8s linear infinite;
      mix-blend-mode: screen;
      pointer-events: none;
    }
    .toggle span {
      position: relative;
      z-index: 1;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .8px;
    }
    .toggle input {
      appearance: none;
      width: 42px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid color-mix(in oklab, var(--sparkle-primary) 42%, #2a2b32);
      background: color-mix(in oklab, var(--sparkle-primary) 16%, #181922);
      position: relative;
      outline: none;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .toggle input::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--sparkle-primary) 60%, #eef1ff),
        color-mix(in oklab, var(--sparkle-primary) 30%, #7f88ff)
      );
      box-shadow: 0 4px 10px rgba(20, 22, 35, 0.6);
      transition: transform 0.2s ease;
    }
    .toggle input:checked {
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--sparkle-primary) 60%, #3f46ff),
        color-mix(in oklab, var(--sparkle-primary) 40%, #252b66)
      );
      border-color: color-mix(in oklab, var(--sparkle-primary) 56%, #3d3f52);
    }
    .toggle input:checked::after {
      transform: translateX(20px);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      border-radius: 999px;
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--sparkle-primary) 18%, #0f1015),
        color-mix(in oklab, var(--sparkle-primary) 8%, #14151c)
      );
      border: 1px solid color-mix(in oklab, var(--sparkle-primary) 24%, #2a2b32);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      position: relative;
      overflow: hidden;
      transition: all 0.2s ease;
      min-height: 44px;
    }
    .pill:hover {
      border-color: color-mix(in oklab, var(--sparkle-primary) 40%, #ffffff15);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,0.04),
        0 2px 8px rgba(0,0,0,0.1);
      transform: translateY(-0.5px);
    }
    .pill::before {
      content: '';
      position: absolute;
      inset: -140% 46% 46% -140%;
      background: linear-gradient(120deg,
        transparent,
        color-mix(in srgb, var(--sparkle-primary) 32%, transparent) 45%,
        transparent
      );
      transform: rotate(16deg);
      animation: shimmer 5.6s linear infinite;
      mix-blend-mode: screen;
      pointer-events: none;
    }
    .pill label {
      font-size: 12px;
      color: color-mix(in oklab, var(--sparkle-primary) 28%, var(--muted));
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-weight: 500;
      min-width: 32px;
    }
    .pill .value-display {
      font-size: 11px;
      color: color-mix(in oklab, var(--sparkle-primary) 60%, var(--fg));
      font-weight: 600;
      min-width: 28px;
      text-align: right;
      background: rgba(255,255,255,0.08);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 4px;
    }
    .pill input[type="range"] {
      background: transparent;
      flex: 1 1 auto;
    }

    .range { accent-color: var(--global-accent, #a9b1ff); transition: accent-color 0.3s ease; }

    .search {
      min-width: 220px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid color-mix(in oklab, var(--sparkle-primary) 26%, #2a2b33);
      background: linear-gradient(140deg,
        color-mix(in oklab, var(--sparkle-primary) 14%, #0f1015),
        #0d0e14);
      color: var(--fg);
      transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.25s ease;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      position: relative;
      overflow: hidden;
    }
    .search::before {
      content: '';
      position: absolute;
      inset: -150% 48% 48% -150%;
      background: linear-gradient(120deg,
        transparent,
        color-mix(in srgb, var(--sparkle-primary) 28%, transparent) 44%,
        transparent
      );
      transform: rotate(14deg);
      animation: shimmer 6.2s linear infinite;
      mix-blend-mode: screen;
      pointer-events: none;
    }
    .search:hover {
      border-color: color-mix(in oklab, var(--sparkle-primary) 52%, #ffffff10);
    }

    .select-shell {
      position: relative;
      display: inline-flex;
      align-items: center;
      border-radius: 12px;
      padding: 0;
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--sparkle-primary) 22%, #111218),
        color-mix(in oklab, var(--sparkle-primary) 12%, #0e0f14));
      border: 1px solid color-mix(in oklab, var(--sparkle-primary) 24%, #2a2b32);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      transition: border-color 0.25s ease, box-shadow 0.25s ease;
      overflow: hidden;
    }
    .select-shell.sparkle::before {
      content: '';
      position: absolute;
      inset: -140% 38% 38% -140%;
      background: linear-gradient(120deg,
        transparent,
        color-mix(in srgb, var(--sparkle-primary) 36%, transparent) 45%,
        transparent
      );
      transform: rotate(10deg);
      animation: shimmer 4.6s linear infinite;
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .select-shell select {
      appearance: none;
      background: transparent;
      border: none;
      padding: 8px 42px 8px 14px;
      color: var(--fg);
      font: inherit;
      cursor: pointer;
      min-width: 160px;
    }
    .select-shell::after {
      content: '▾';
      position: absolute;
      right: 14px;
      font-size: 12px;
      pointer-events: none;
      color: color-mix(in oklab, var(--sparkle-primary) 58%, #c7ccff);
      transform: translateY(1px);
    }
    .select-shell:hover {
      border-color: color-mix(in oklab, var(--sparkle-primary) 40%, #ffffff10);
    }
    .select-shell:focus-within {
      border-color: color-mix(in oklab, var(--sparkle-primary) 60%, #ffffff18);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--sparkle-primary) 20%, transparent);
    }

    .dropzone {
      border: 1.5px dashed #35373d; border-radius: 14px; padding: 18px; margin: 12px auto 0; text-align: center; color: var(--muted);
      background: repeating-linear-gradient(45deg, #0f1013, #0f1013 10px, #0e0f12 10px, #0e0f12 20px);
    }
    .dropzone.drag { border-color: #8aa0ff; color: #c7d0ff; background: #0e1020; }
    body.live-mode #drop,
    body.live-mode .meta {
      display: none;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(7, 8, 12, 0.76);
      backdrop-filter: blur(18px) saturate(140%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 20;
    }
    .modal-backdrop.show {
      opacity: 1;
      pointer-events: auto;
    }
    .modal {
      width: min(92vw, 720px);
      max-height: min(88vh, 640px);
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: linear-gradient(160deg, rgba(16,17,22,0.96), rgba(13,14,18,0.92));
      border: 1px solid rgba(92, 101, 138, 0.28);
      border-radius: 18px;
      padding: 22px 24px 24px;
      box-shadow: 0 30px 80px rgba(4, 6, 12, 0.65);
      position: relative;
      transform: translateY(16px);
      opacity: 0;
      transition: transform 0.28s ease, opacity 0.28s ease;
    }
    .modal-backdrop.show .modal {
      transform: translateY(0);
      opacity: 1;
    }
    .modal-header { display: flex; justify-content: space-between; align-items: center; gap: 14px; }
    .modal-title { font-size: 18px; letter-spacing: 0.4px; margin: 0; }
    .modal-subtitle { margin: -6px 0 4px; color: var(--muted); font-size: 13px; }
    .modal-body { display: grid; gap: 16px; }

    .field { display: grid; gap: 8px; }
    .field .label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: var(--muted); }
    .field textarea {
      width: 100%;
      min-height: 180px;
      resize: vertical;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(55, 57, 66, 0.9);
      background: rgba(10, 11, 15, 0.9);
      color: var(--fg);
      font: 13px/1.5 "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      caret-color: var(--global-accent, #a9b1ff);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .field textarea:focus {
      outline: none;
      border-color: var(--global-accent, #7982ff);
      box-shadow: 0 0 0 3px rgba(125, 131, 255, 0.2);
    }

    .preview-shell {
      border: 1px solid rgba(55,57,66,0.8);
      border-radius: 16px;
      background: rgba(12, 13, 18, 0.85);
      padding: 14px;
      display: grid;
      gap: 10px;
    }
    .preview-header { display: flex; justify-content: space-between; align-items: center; color: var(--muted); font-size: 12px; }
    .badge {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(93, 101, 148, 0.22);
      color: #bfc5ff;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
    }
    .badge.good {
      background: rgba(125, 190, 120, 0.22);
      color: #d5ffd1;
    }
    .badge.bad {
      background: rgba(214, 76, 98, 0.22);
      color: #ffc3cb;
    }
    .preview-stage {
      min-height: 160px;
      border-radius: 12px;
      padding: 14px;
      display: grid;
      place-items: center;
      text-align: center;
      background:
        linear-gradient(45deg, rgba(18, 19, 28, 0.92), rgba(15, 15, 22, 0.92)),
        repeating-linear-gradient(45deg, rgba(18, 19, 24, 0.6) 0 20px, rgba(12,13,18,0.6) 20px 40px);
      border: 1px dashed rgba(87, 90, 110, 0.4);
      position: relative;
    }
    .preview-stage img {
      max-width: min(100%, 360px);
      max-height: 240px;
    }
    .preview-stage.empty { color: var(--muted); font-size: 13px; }

    .modal-footer {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .modal-actions { display: flex; gap: 10px; }

    @keyframes shimmer {
      0% { transform: translateX(-60%) rotate(12deg); }
      100% { transform: translateX(180%) rotate(12deg); }
    }

    .meta { display: flex; gap: 10px; align-items: center; color: var(--muted); font-size: 12px; }

    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(var(--thumb), 1fr)); gap: var(--gap); padding: 18px; }

    .card {
      position: relative;
      border: 1px solid #222329;
      background: #101114;
      border-radius: 14px;
      overflow: clip;
      display: flex;
      flex-direction: column;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .thumb-wrap { position: relative; aspect-ratio: 1 / 1; display: grid; place-items: center; background: conic-gradient(from 0deg, #0a0b0d, #0c0d10);
      /* checkerboard */
      --c:#15161a; --d:#101217;
      background:
        linear-gradient(45deg, var(--d) 25%, transparent 25%) 0 0/16px 16px,
        linear-gradient(-45deg, var(--d) 25%, transparent 25%) 0 0/16px 16px,
        linear-gradient(45deg, transparent 75%, var(--d) 75%) 0 0/16px 16px,
        linear-gradient(-45deg, transparent 75%, var(--d) 75%) 0 0/16px 16px,
        repeating-conic-gradient(from 0deg, #0b0c0f 0% 25%, #0b0c10 0% 50%);
    }
    .thumb-wrap.dark { background: #0c0d10; }
    .thumb-wrap.transparent { background: #0b0c0f; }

    .thumb { max-width: 80%; max-height: 80%; object-fit: contain; }

    .card .info { padding: 10px 12px; display: grid; gap: 6px; position: relative; }
    .name { font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .sub { font-size: 12px; color: var(--muted); }

    .color-indicator {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid var(--bg);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.1);
    }

    .actions { display: flex; gap: 8px; margin-top: 6px; }
    .actions a, .actions button { flex: 1; text-align: center; }

    .workspace-switch {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .live-workspace {
      display: grid;
      gap: 16px;
      padding: 18px;
      max-width: 1200px;
      margin: 0 auto;
      color: var(--fg);
    }
    .live-workspace .workspace-header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      padding: 0 4px;
    }
    .live-workspace .workspace-title {
      font-size: 18px;
      letter-spacing: 0.4px;
      display: inline-flex;
      gap: 10px;
      align-items: center;
    }
    .live-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #ffb9c2;
      background: rgba(255, 92, 122, 0.16);
      border: 1px solid rgba(255, 118, 146, 0.3);
      border-radius: 999px;
      padding: 4px 10px;
      box-shadow: 0 0 16px rgba(255, 120, 150, 0.12);
    }
    .workspace-meta {
      display: flex;
      align-items: center;
      gap: 14px;
      font-size: 12px;
      color: color-mix(in oklab, var(--sparkle-primary) 26%, var(--muted));
    }
    .workspace-meta span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .workspace-body {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 16px;
    }
    .pane {
      border: 1px solid rgba(49, 52, 64, 0.8);
      border-radius: 18px;
      background: linear-gradient(160deg, rgba(16,18,26,0.95), rgba(13,15,22,0.92));
      box-shadow: 0 24px 60px rgba(5, 7, 12, 0.55);
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    .pane-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 16px 18px 8px;
      font-size: 13px;
      color: color-mix(in oklab, var(--sparkle-primary) 32%, var(--muted));
    }
    .pane-actions {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    #liveError {
      color: rgba(255, 140, 163, 0.88);
      font-size: 12px;
      max-width: 320px;
    }
    .editor-box {
      position: relative;
      margin: 0 18px 12px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(56, 60, 80, 0.6);
      background: rgba(10, 11, 18, 0.9);
    }
    .editor-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 2;
    }
    .line-highlight {
      position: absolute;
      left: 0;
      right: 0;
      height: 1.5em;
      background: rgba(255, 110, 132, 0.18);
    }
    .line-highlight.diff {
      background: color-mix(in srgb, var(--sparkle-primary) 24%, transparent);
    }
    .line-highlight.error {
      background: rgba(255, 118, 146, 0.24);
      border-top: 1px solid rgba(255, 118, 146, 0.4);
      border-bottom: 1px solid rgba(255, 118, 146, 0.4);
    }
    .workspace-textarea {
      position: relative;
      z-index: 1;
      width: 100%;
      min-height: 420px;
      resize: vertical;
      border: none;
      background: transparent;
      color: var(--fg);
      padding: 18px;
      font: 13px/1.5 "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      tab-size: 2;
      white-space: pre;
      outline: none;
    }
    .workspace-textarea.error {
      box-shadow: inset 0 0 0 2px rgba(255, 118, 146, 0.35);
    }
    .editor-footer {
      padding: 0 18px 16px;
      font-size: 12px;
      color: color-mix(in oklab, var(--sparkle-primary) 22%, var(--muted));
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }

    .preview-pane {
      position: relative;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    .live-preview {
      position: relative;
      margin: 0 18px 12px;
      border-radius: 16px;
      border: 1px solid rgba(56, 60, 80, 0.6);
      background:
        linear-gradient(135deg, rgba(16,18,24,0.92), rgba(10,12,18,0.9)),
        repeating-linear-gradient(45deg, rgba(18,19,26,0.4) 0 20px, rgba(10,11,16,0.4) 20px 40px);
      display: grid;
      min-height: 420px;
      overflow: hidden;
    }
    .live-preview iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      grid-area: 1 / 1 / 2 / 2;
    }
    .preview-placeholder {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 28px;
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      max-width: 360px;
      margin: 0 auto;
      line-height: 1.6;
    }
    .diff-panel {
      padding: 0 18px 18px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
      color: color-mix(in oklab, var(--sparkle-primary) 26%, var(--muted));
    }
    .diff-summary {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(111, 120, 255, 0.12);
      color: color-mix(in oklab, var(--sparkle-primary) 58%, #cbd0ff);
    }
    .diff-details {
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      color: color-mix(in oklab, var(--sparkle-primary) 34%, var(--muted));
      white-space: pre-wrap;
      word-break: break-word;
    }

    .workspace-body.compact {
      grid-template-columns: 1fr;
    }
    @media (max-width: 980px) {
      .workspace-body {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 700px) {
      .workspace-textarea {
        min-height: 320px;
      }
      .live-preview {
        min-height: 320px;
      }
    }

    @media (max-width: 900px) {
      .control-bar {
        flex-direction: column;
        align-items: stretch;
        gap: 14px;
      }
      .control-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .control-group .pill {
        grid-column: span 1;
      }
      .control-group .select-shell {
        grid-column: 1 / -1;
      }
      .control-group .workspace-switch {
        grid-column: 1 / -1;
        justify-self: center;
      }
      .controls .search {
        max-width: none;
      }
    }
    @media (max-width: 720px) {
      .brand { flex-direction: column; align-items: flex-start; gap: 14px; }
      .brand-logo { width: clamp(200px, 60vw, 360px); }
      .footer-inner { align-items: center; gap: 16px; }
    }

    .footer {
      position: relative;
      padding: 48px 18px 64px;
      color: var(--muted);
      border-top: 1px solid #1f2023;
      overflow: hidden;
      background: #0b0d14;
    }
    .footer::before {
      content: '';
      position: absolute;
      inset: 0;
      backdrop-filter: blur(20px) saturate(140%);
      background: linear-gradient(180deg, rgba(13,15,26,0.92) 0%, rgba(9,11,18,0.92) 100%);
      opacity: 0.92;
      z-index: 0;
    }
    .footer-art {
      position: relative;
      z-index: 0;
      max-width: min(90vw, 960px);
      margin: 0 auto;
      pointer-events: none;
    }
    .footer-art img {
      width: 100%;
      height: auto;
      display: block;
      opacity: 0.95;
    }
    .footer-inner {
      position: relative;
      z-index: 1;
      max-width: min(90vw, 960px);
      margin: 32px auto 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
      text-align: center;
    }
    .footer-content { display: flex; flex-direction: column; gap: 8px; max-width: 520px; }

    .hide { display: none !important; }

    .card.flash {
      animation: card-pop 0.6s ease;
    }
    @keyframes card-pop {
      0% { transform: scale(0.94); box-shadow: 0 0 0 rgba(128, 136, 255, 0); }
      55% { transform: scale(1.04); box-shadow: 0 0 32px rgba(125, 134, 255, 0.24); }
      100% { transform: scale(1); box-shadow: 0 0 0 rgba(128, 136, 255, 0); }
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="brand">
        <span class="brand-logo"><img src="logo.svg" alt="SVG Gallery Viewer" /></span>
        <h1 class="visually-hidden">SVG Gallery Viewer</h1>
      </div>
      <div class="controls">
        <div class="control-bar">
          <div class="control-group">
            <label class="btn sparkle file-input">
              <input id="file" type="file" multiple accept="image/svg+xml,.svg" />
              ➕ Add SVGs
            </label>
            <button id="openPaste" class="btn sparkle" type="button">✨ Paste SVG</button>

            <div class="pill">
              <label for="zoom">Zoom</label>
              <input id="zoom" class="range" type="range" min="120" max="320" value="180" />
              <span id="zoomValue" class="value-display">180px</span>
            </div>
            <div class="pill">
              <label for="gap">Gap</label>
              <input id="gap" class="range" type="range" min="6" max="28" value="14" />
              <span id="gapValue" class="value-display">14px</span>
            </div>

            <div class="select-shell sparkle">
              <select id="bgMode" title="Thumbnail background">
                <option value="checker">Checkerboard</option>
                <option value="transparent">Transparent</option>
                <option value="dark">Dark</option>
              </select>
            </div>

            <div class="workspace-switch">
              <label class="toggle" for="liveToggle">
                <span>Live Edit</span>
                <input id="liveToggle" type="checkbox" role="switch" aria-checked="false" />
              </label>
            </div>

            <button id="exportList" class="btn" type="button">Export list</button>
            <button id="clear" class="btn" type="button" title="Remove all">🗑️ Clear</button>
          </div>
          <input id="search" class="search" type="search" placeholder="Filter by filename…" />
        </div>
      </div>
      <div id="drop" class="dropzone">Drag & drop SVG files here</div>
      <div class="meta"><span id="count">0 files</span><span id="totalSize">0 KB</span></div>
    </div>
  </header>

  <main>
    <div id="galleryWrap">
      <section id="grid" class="grid" aria-live="polite"></section>
    </div>
    <section id="liveWorkspace" class="live-workspace hide" aria-hidden="true">
      <header class="workspace-header">
        <div class="workspace-title">
          <span class="live-badge">● Live</span>
          <span>Edit Workspace</span>
        </div>
        <div class="workspace-meta">
          <span id="liveStatus">Idle • 0 chars</span>
          <span id="liveDiff">Δ 0</span>
        </div>
      </header>
      <div class="workspace-body">
        <article class="pane">
          <div class="pane-header">
            <span>SVG Markup</span>
            <span id="liveError" aria-live="polite"></span>
          </div>
          <div class="editor-box">
            <div id="editorOverlay" class="editor-overlay"></div>
            <textarea id="liveEditor" class="workspace-textarea" spellcheck="false" aria-label="Live SVG editor"></textarea>
          </div>
          <div class="editor-footer">
            <span id="lineStats">Line 1 • Column 1</span>
            <span id="autoSaveStatus">Saved</span>
          </div>
        </article>
        <article class="pane preview-pane">
          <div class="pane-header">
            <span>Live Preview</span>
            <div class="pane-actions">
              <button id="copyMarkup" class="btn sparkle" type="button">Copy</button>
              <button id="addLiveToGallery" class="btn primary" type="button">Add to gallery</button>
            </div>
          </div>
          <div class="live-preview">
            <div id="previewPlaceholder" class="preview-placeholder">Your SVG render will appear here in real time.</div>
            <iframe id="liveFrame" title="Live SVG preview" sandbox="allow-scripts allow-same-origin"></iframe>
          </div>
          <div class="diff-panel">
            <div id="diffSummary" class="diff-summary">No changes yet</div>
            <div id="diffDetails" class="diff-details"></div>
          </div>
        </article>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div class="footer-art" aria-hidden="true">
      <img src="footer.svg" alt="" />
    </div>
    <div class="footer-inner">
      <div class="footer-content">
        <small>Local-only. Files never leave your browser. Previews use <code>&lt;img&gt;</code> for safety.</small>
        <small>Powered by your SVGs — live edits sync straight into the gallery.</small>
      </div>
    </div>
  </footer>

  <div id="pasteModal" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="pasteTitle">
      <div class="modal-header">
        <h2 id="pasteTitle" class="modal-title">Paste SVG Markup</h2>
        <button id="closePaste" class="icon-btn" type="button" aria-label="Close paste dialog">✕</button>
      </div>
      <p class="modal-subtitle">Drop in raw SVG code, get a live preview, and elevate your gallery in one click.</p>
      <div class="modal-body">
        <label class="field" for="svgInput">
          <span class="label">SVG markup</span>
          <textarea id="svgInput" placeholder="&lt;svg width=&quot;128&quot; height=&quot;128&quot; ...&gt;" spellcheck="false"></textarea>
        </label>
        <div class="preview-shell">
          <div class="preview-header">
            <span>Live preview</span>
            <span id="validationBadge" class="badge">Awaiting SVG</span>
          </div>
          <div id="svgPreview" class="preview-stage empty">
            <span>Preview updates as soon as your SVG is valid.</span>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <span id="codeMeta">0 characters • 0 B</span>
        <div class="modal-actions">
          <button id="resetSvgInput" class="btn" type="button">Reset</button>
          <button id="addFromCode" class="btn primary" type="button" disabled>Add to gallery</button>
        </div>
      </div>
    </div>
  </div>

  <template id="cardTpl">
    <article class="card" data-name="" data-size="0">
      <div class="thumb-wrap checker"><img class="thumb" alt="SVG preview" /></div>
      <div class="info">
        <div class="name"></div>
        <div class="sub"></div>
        <div class="actions">
          <a class="btn open" target="_blank" rel="noopener">Open</a>
          <a class="btn download" download>Download</a>
        </div>
      </div>
    </article>
  </template>

  <script>
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    // Color extraction and analysis utilities
    class ColorExtractor {
      static async extractColors(svgUrl) {
        try {
          const response = await fetch(svgUrl);
          const svgText = await response.text();

          // Parse SVG and extract colors
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
          const colors = new Set();

          // Extract from fill attributes
          const fillElements = svgDoc.querySelectorAll('[fill]');
          fillElements.forEach(el => {
            const fill = el.getAttribute('fill');
            if (fill && fill !== 'none' && !fill.includes('url(')) {
              colors.add(fill);
            }
          });

          // Extract from stroke attributes
          const strokeElements = svgDoc.querySelectorAll('[stroke]');
          strokeElements.forEach(el => {
            const stroke = el.getAttribute('stroke');
            if (stroke && stroke !== 'none' && !stroke.includes('url(')) {
              colors.add(stroke);
            }
          });

          // Extract from style attributes
          const styledElements = svgDoc.querySelectorAll('[style]');
          styledElements.forEach(el => {
            const style = el.getAttribute('style');
            const fillMatch = style.match(/fill:\s*([^;]+)/);
            const strokeMatch = style.match(/stroke:\s*([^;]+)/);
            if (fillMatch && fillMatch[1] !== 'none') colors.add(fillMatch[1].trim());
            if (strokeMatch && strokeMatch[1] !== 'none') colors.add(strokeMatch[1].trim());
          });

          return Array.from(colors).filter(color =>
            color !== 'currentColor' &&
            color !== 'inherit' &&
            !color.includes('var(')
          );
        } catch (error) {
          console.warn('Color extraction failed:', error);
          return [];
        }
      }

      static hexToHsl(hex) {
        // Convert hex to RGB first
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }

        return [h * 360, s * 100, l * 100];
      }

      static normalizeColor(color) {
        // Create a temporary element to get computed color
        const temp = document.createElement('div');
        temp.style.color = color;
        document.body.appendChild(temp);
        const computed = getComputedStyle(temp).color;
        document.body.removeChild(temp);

        // Extract RGB values
        const rgbMatch = computed.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
          const r = parseInt(rgbMatch[1]);
          const g = parseInt(rgbMatch[2]);
          const b = parseInt(rgbMatch[3]);
          return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }

        return color.startsWith('#') ? color : null;
      }

      static getDominantColor(colors) {
        if (!colors.length) return null;

        // Normalize colors and filter valid hex colors
        const normalizedColors = colors
          .map(color => this.normalizeColor(color))
          .filter(color => color && color.match(/^#[0-9A-Fa-f]{6}$/));

        if (!normalizedColors.length) return null;

        // Find most vibrant color (highest saturation)
        let dominantColor = normalizedColors[0];
        let maxSaturation = 0;

        normalizedColors.forEach(color => {
          const [h, s, l] = this.hexToHsl(color);
          // Prefer colors with good saturation and not too dark/light
          const vibrancy = s * (1 - Math.abs(l - 50) / 50);
          if (vibrancy > maxSaturation) {
            maxSaturation = vibrancy;
            dominantColor = color;
          }
        });

        return dominantColor;
      }

      static getContrastRatio(color1, color2) {
        const getLuminance = (color) => {
          const rgb = [
            parseInt(color.slice(1, 3), 16),
            parseInt(color.slice(3, 5), 16),
            parseInt(color.slice(5, 7), 16)
          ].map(c => {
            c = c / 255;
            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
          });
          return 0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2];
        };

        const lum1 = getLuminance(color1);
        const lum2 = getLuminance(color2);
        const brightest = Math.max(lum1, lum2);
        const darkest = Math.min(lum1, lum2);

        return (brightest + 0.05) / (darkest + 0.05);
      }

      static generateColorScheme(dominantColor) {
        if (!dominantColor) return null;

        const [h, s, l] = this.hexToHsl(dominantColor);

        // Generate complementary and accent colors
        const accent = `hsl(${h}, ${Math.max(s - 10, 30)}%, ${Math.min(l + 10, 80)}%)`;
        const complement = `hsl(${(h + 180) % 360}, ${s * 0.7}%, ${l * 0.8}%)`;
        const subtle = `hsl(${h}, ${s * 0.3}%, ${l * 0.4}%)`;

        return {
          primary: dominantColor,
          accent,
          complement,
          subtle
        };
      }
    }

    const grid = $('#grid');
    const fileInput = $('#file');
    const drop = $('#drop');
    const search = $('#search');
    const clearBtn = $('#clear');
    const zoom = $('#zoom');
    const gap = $('#gap');
    const count = $('#count');
    const totalSize = $('#totalSize');
    const bgMode = $('#bgMode');
    const exportList = $('#exportList');
    const openPasteBtn = $('#openPaste');
    const pasteModal = $('#pasteModal');
    const closePasteBtn = $('#closePaste');
    const svgInput = $('#svgInput');
    const svgPreview = $('#svgPreview');
    const validationBadge = $('#validationBadge');
    const codeMeta = $('#codeMeta');
    const resetSvgInputBtn = $('#resetSvgInput');
    const addFromCodeBtn = $('#addFromCode');
    const liveToggle = $('#liveToggle');
    const galleryWrap = $('#galleryWrap');
    const liveWorkspace = $('#liveWorkspace');
    const liveEditor = $('#liveEditor');
    const liveStatus = $('#liveStatus');
    const liveDiff = $('#liveDiff');
    const liveError = $('#liveError');
    const editorOverlay = $('#editorOverlay');
    const lineStats = $('#lineStats');
    const autoSaveStatus = $('#autoSaveStatus');
    const liveFrame = $('#liveFrame');
    const previewPlaceholder = $('#previewPlaceholder');
    const diffSummary = $('#diffSummary');
    const diffDetails = $('#diffDetails');
    const copyMarkupBtn = $('#copyMarkup');
    const addLiveToGalleryBtn = $('#addLiveToGallery');

    let filesState = []; // { name, size, url, type }
    let pastePreviewUrl = null;
    let cachedSvgRoot = null;
    let pasteNameCounter = 1;
    let liveModeEnabled = false;
    let lastRenderedMarkup = '';
    let lastValidMarkup = '';
    let scheduledSave = null;
    let editorLineHeight = 21;
    let editorPaddingTop = 18;
    let diffLines = [];
    let errorLine = null;
    const DEFAULT_SVG_SAMPLE = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="240" height="240" viewBox="0 0 240 240" fill="none" xmlns="http://www.w3.org/2000/svg" role="img" aria-labelledby="title desc">
  <title id="title">Gradient Orbital</title>
  <desc id="desc">Demo SVG for the live editor preview</desc>
  <defs>
    <radialGradient id="glow" cx="50%" cy="50%" r="60%">
      <stop offset="0%" stop-color="#9aa2ff" stop-opacity="0.94" />
      <stop offset="50%" stop-color="#6f7bff" stop-opacity="0.76" />
      <stop offset="100%" stop-color="#1d2038" stop-opacity="0" />
    </radialGradient>
    <linearGradient id="wave" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="#9aa8ff" />
      <stop offset="50%" stop-color="#6ae3ff" />
      <stop offset="100%" stop-color="#62ffca" />
    </linearGradient>
  </defs>
  <rect width="240" height="240" rx="28" fill="#0f111b" />
  <circle cx="120" cy="120" r="96" fill="url(#glow)" />
  <path d="M44 120c0-42 34-76 76-76s76 34 76 76-34 76-76 76S44 162 44 120Z" stroke="url(#wave)" stroke-width="6" fill="none" />
  <circle cx="168" cy="92" r="12" fill="#ffffff" fill-opacity="0.9" />
  <circle cx="92" cy="148" r="8" fill="#8df5ff" fill-opacity="0.8" />
</svg>`;

    function fmtBytes(bytes){
      if(bytes === 0) return '0 B';
      const k = 1024, dm = 1, sizes = ['B','KB','MB','GB'];
      const i = Math.min(Math.floor(Math.log(bytes)/Math.log(k)), sizes.length-1);
      return parseFloat((bytes/Math.pow(k,i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function updateMeta(){
      count.textContent = `${filesState.length} file${filesState.length!==1?'s':''}`;
      const total = filesState.reduce((a,f)=>a+f.size,0);
      totalSize.textContent = fmtBytes(total);
    }

    function setGridControls(){
      document.documentElement.style.setProperty('--thumb', zoom.value+'px');
      document.documentElement.style.setProperty('--gap', gap.value+'px');
    }

    function setThumbBg(){
      $$('.thumb-wrap').forEach(el => {
        el.classList.remove('checker','transparent','dark');
        const v = bgMode.value;
        if(v==='transparent') el.classList.add('transparent');
        else if(v==='dark') el.classList.add('dark');
        else el.classList.add('checker');
      });
    }

    function parseSvgMarkup(markup) {
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(markup, 'image/svg+xml');
        const parserError = doc.querySelector('parsererror');
        const svgEl = doc.querySelector('svg');

        if (parserError || !svgEl) {
          const rawMessage = parserError ? parserError.textContent || '' : 'SVG root element missing.';
          const message = rawMessage.replace(/\s+/g, ' ').trim().slice(0, 220) || 'Unable to parse SVG markup.';
          const lineMatch = rawMessage.match(/Line:\s*(\d+)/i);
          const colMatch = rawMessage.match(/Column:\s*(\d+)/i);
          const line = lineMatch ? parseInt(lineMatch[1], 10) : null;
          const column = colMatch ? parseInt(colMatch[1], 10) : null;
          return { valid: false, error: message, line, column };
        }

        return { valid: true, svg: svgEl, line: null, column: null, doc };
      } catch (error) {
        return { valid: false, error: 'Unable to process SVG input.' };
      }
    }

    function updateSvgInputState(){
      if (!svgInput) return;

      const rawValue = svgInput.value;
      const trimmedValue = rawValue.trim();
      const charCount = rawValue.length;
      const sizeBytes = new Blob([rawValue]).size;
      const charLabel = `${charCount} character${charCount === 1 ? '' : 's'}`;
      codeMeta.textContent = `${charLabel} • ${fmtBytes(sizeBytes)}`;

      if (pastePreviewUrl) {
        URL.revokeObjectURL(pastePreviewUrl);
        pastePreviewUrl = null;
      }

      if (!trimmedValue) {
        svgPreview.classList.add('empty');
        svgPreview.innerHTML = '';
        const placeholder = document.createElement('span');
        placeholder.textContent = 'Preview updates as soon as your SVG is valid.';
        svgPreview.appendChild(placeholder);
        validationBadge.textContent = 'Awaiting SVG';
        validationBadge.classList.remove('good', 'bad');
        addFromCodeBtn.disabled = true;
        cachedSvgRoot = null;
        return;
      }

      const parsed = parseSvgMarkup(trimmedValue);
      if (!parsed.valid) {
        svgPreview.classList.add('empty');
        svgPreview.innerHTML = '';
        const errorMsg = document.createElement('span');
        errorMsg.textContent = parsed.error;
        svgPreview.appendChild(errorMsg);
        validationBadge.textContent = 'Needs attention';
        validationBadge.classList.add('bad');
        validationBadge.classList.remove('good');
        addFromCodeBtn.disabled = true;
        cachedSvgRoot = null;
        return;
      }

      const blob = new Blob([trimmedValue], { type: 'image/svg+xml' });
      pastePreviewUrl = URL.createObjectURL(blob);

      const img = document.createElement('img');
      img.src = pastePreviewUrl;
      img.alt = 'SVG preview from pasted code';
      img.loading = 'lazy';
      img.decoding = 'async';

      svgPreview.innerHTML = '';
      svgPreview.classList.remove('empty');
      svgPreview.appendChild(img);

      validationBadge.textContent = 'Ready to add';
      validationBadge.classList.add('good');
      validationBadge.classList.remove('bad');
      addFromCodeBtn.disabled = false;
      cachedSvgRoot = parsed.svg;
    }

    function buildUniqueSvgName(svgEl){
      const candidates = [];
      if (svgEl) {
        const titleNode = svgEl.querySelector('title');
        if (titleNode && titleNode.textContent.trim()) candidates.push(titleNode.textContent.trim());
        const id = svgEl.getAttribute('id');
        if (id && id.trim()) candidates.push(id.trim());
        const aria = svgEl.getAttribute('aria-label');
        if (aria && aria.trim()) candidates.push(aria.trim());
      }

      let base = candidates.find(Boolean);
      if (!base) {
        base = `Pasted SVG ${pasteNameCounter++}`;
      }

      base = base.replace(/[\\/:*?"<>|#]+/g, ' ').replace(/\s+/g, ' ').trim();
      if (!base) {
        base = `Pasted SVG ${pasteNameCounter++}`;
      }

      let candidate = base.toLowerCase().endsWith('.svg') ? base : `${base}.svg`;
      let suffix = 2;
      const baseName = candidate.replace(/\.svg$/i, '');
      while (filesState.some(f => f.name.toLowerCase() === candidate.toLowerCase())) {
        candidate = `${baseName} ${suffix}.svg`;
        suffix++;
      }
      return candidate;
    }

    function focusTextareaSoon(){
      if (!svgInput) return;
      requestAnimationFrame(() => svgInput.focus({ preventScroll: true }));
    }

    function getLineCount(text) {
      if (!text) return 1;
      return text.split(/\r?\n/).length;
    }

    function updateEditorMetrics(){
      if (!liveEditor) return;
      const styles = getComputedStyle(liveEditor);
      const lh = parseFloat(styles.lineHeight);
      const padTop = parseFloat(styles.paddingTop);
      if (!Number.isNaN(lh)) editorLineHeight = lh;
      if (!Number.isNaN(padTop)) editorPaddingTop = padTop;
    }

    function setLiveStatus(text) {
      if (liveStatus) liveStatus.textContent = text;
    }

    function setDiffSummary(text) {
      if (liveDiff) liveDiff.textContent = text;
      if (diffSummary) diffSummary.textContent = text;
    }

    function setDiffDetails(text) {
      if (diffDetails) diffDetails.textContent = text;
    }

    function setAutoSaveStatus(text, transient = false) {
      if (!autoSaveStatus) return;
      autoSaveStatus.textContent = text;
      if (transient) {
        autoSaveStatus.dataset.state = 'pending';
        clearTimeout(autoSaveStatus._timer);
        autoSaveStatus._timer = setTimeout(() => {
          autoSaveStatus.textContent = 'Saved';
          autoSaveStatus.dataset.state = 'saved';
        }, 800);
      }
    }

    function updateLineStats() {
      if (!liveEditor || !lineStats) return;
      const value = liveEditor.value;
      const cursor = liveEditor.selectionStart || 0;
      const untilCursor = value.slice(0, cursor);
      const lines = untilCursor.split(/\r?\n/);
      const line = lines.length;
      const column = lines[lines.length - 1].length + 1;
      lineStats.textContent = `Line ${line} • Column ${column}`;
    }

    function computeLineDiff(prev, next) {
      const prevLines = prev.split(/\r?\n/);
      const nextLines = next.split(/\r?\n/);
      const max = Math.max(prevLines.length, nextLines.length);
      const changed = [];
      let added = 0;
      let removed = 0;

      for (let i = 0; i < max; i++) {
        const prevLine = prevLines[i];
        const nextLine = nextLines[i];
        if (prevLine === undefined && nextLine !== undefined) {
          added++;
          changed.push(i + 1);
        } else if (nextLine === undefined && prevLine !== undefined) {
          removed++;
        } else if (prevLine !== nextLine) {
          changed.push(i + 1);
        }
      }

      return {
        changedLines: [...new Set(changed)],
        addedCount: added,
        removedCount: removed
      };
    }

    function highlightLines({ error, diffs }) {
      if (!editorOverlay) return;
      editorOverlay.innerHTML = '';
      const scrollTop = liveEditor ? liveEditor.scrollTop : 0;
      const paddingTop = editorPaddingTop || 0;
      const lineHeight = editorLineHeight || 20;

      function appendLine(line, className) {
        if (!line || line < 1) return;
        const div = document.createElement('div');
        div.className = `line-highlight ${className}`;
        div.style.top = `${paddingTop + (line - 1) * lineHeight - scrollTop}px`;
        div.style.height = `${lineHeight}px`;
        editorOverlay.appendChild(div);
      }

      if (Array.isArray(diffs)) {
        diffs.slice(0, 60).forEach(line => appendLine(line, 'diff'));
      }

      if (error) {
        appendLine(error, 'error');
      }
    }

    function updateHighlights() {
      highlightLines({ error: errorLine, diffs: diffLines });
    }

    function persistLivePreference(enabled) {
      try {
        localStorage.setItem('svgviewer.liveEdit', enabled ? '1' : '0');
      } catch (err) {
        console.warn('Unable to store live edit preference', err);
      }
    }

    function persistLiveMarkup(markup) {
      try {
        localStorage.setItem('svgviewer.liveMarkup', markup);
      } catch (err) {
        console.warn('Unable to store live edit markup', err);
      }
    }

    function applyLivePreview(markup) {
      if (!liveFrame) return;
      liveFrame.srcdoc = markup;
      if (previewPlaceholder) previewPlaceholder.classList.add('hide');
      lastRenderedMarkup = markup;
    }

    function resetLivePreview() {
      if (liveFrame) liveFrame.srcdoc = '';
      if (previewPlaceholder) previewPlaceholder.classList.remove('hide');
      setDiffSummary('Δ 0');
      setDiffDetails('');
      diffLines = [];
      lastRenderedMarkup = '';
      updateHighlights();
    }

    function scheduleMarkupSave(markup) {
      if (scheduledSave) clearTimeout(scheduledSave);
      scheduledSave = setTimeout(() => {
        persistLiveMarkup(markup);
        setAutoSaveStatus('Saved');
      }, 400);
    }

    async function addMarkupToGallery(markup, svgRoot, { source = 'pasted' } = {}) {
      const blob = new Blob([markup], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const name = buildUniqueSvgName(svgRoot);

      filesState.push({ name, size: blob.size, url, type: source });
      const pseudoFile = { name, size: blob.size };
      const card = await makeCard(pseudoFile, url);

      if (grid.firstChild) grid.prepend(card); else grid.appendChild(card);
      card.classList.add('flash');
      setTimeout(() => card.classList.remove('flash'), 700);

      setThumbBg();
      updateMeta();
      applyFilter();
      updateGlobalTheme();

      return { name, url, card };
    }

    function updateDiffUI(diff) {
      if (!diff) {
        setDiffSummary('Δ 0');
        setDiffDetails('');
        return;
      }
      const { addedCount, removedCount, changedLines } = diff;
      if (addedCount === 0 && removedCount === 0 && changedLines.length === 0) {
        setDiffSummary('Δ 0');
        setDiffDetails('');
      } else {
        const summary = `Δ +${addedCount} • ~${changedLines.length} • -${removedCount}`;
        setDiffSummary(summary);
        const changedText = changedLines.length ? `Changed lines: ${changedLines.join(', ')}` : '';
        const removedText = removedCount ? `${removedCount} line${removedCount === 1 ? '' : 's'} removed` : '';
        setDiffDetails([changedText, removedText].filter(Boolean).join('\n'));
      }
    }

    function copyLiveMarkup() {
      if (!copyMarkupBtn || !liveEditor) return;
      const text = liveEditor.value;
      if (!text.trim()) {
        copyMarkupBtn.textContent = 'Nothing to copy';
        copyMarkupBtn.disabled = true;
        setTimeout(() => {
          copyMarkupBtn.disabled = false;
          copyMarkupBtn.textContent = 'Copy';
        }, 900);
        return;
      }
      if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          copyMarkupBtn.textContent = 'Copied!';
          setTimeout(() => { copyMarkupBtn.textContent = 'Copy'; }, 1100);
        }).catch(() => {
          copyMarkupBtn.textContent = 'Copy failed';
          setTimeout(() => { copyMarkupBtn.textContent = 'Copy'; }, 1100);
        });
      } else {
        copyMarkupBtn.textContent = 'Unsupported';
        setTimeout(() => { copyMarkupBtn.textContent = 'Copy'; }, 1100);
      }
    }

    async function addLiveMarkupToGallery() {
      if (!liveEditor) return;
      const markup = liveEditor.value;
      const trimmed = markup.trim();

      if (!trimmed) {
        setLiveStatus('Nothing to add yet');
        if (liveError) liveError.textContent = 'Type some SVG first, then add it to your gallery.';
        return;
      }

      const parsed = parseSvgMarkup(markup);
      if (!parsed.valid || !parsed.svg) {
        liveEditor.classList.add('error');
        errorLine = parsed.line || 1;
        diffLines = [];
        updateHighlights();
        if (liveError) liveError.textContent = parsed.error || 'Fix SVG issues before adding to gallery.';
        setLiveStatus('Fix errors before adding');
        setDiffSummary('Δ fix parsing error');
        setDiffDetails(parsed.error || '');
        return;
      }

      try {
        const { name } = await addMarkupToGallery(markup, parsed.svg, { source: 'live' });
        liveEditor.classList.remove('error');
        errorLine = null;
        diffLines = [];
        updateHighlights();
        setLiveStatus(`Added “${name}” to gallery`);
        setDiffSummary('Δ synced to gallery');
        setDiffDetails(`The latest markup is now saved as “${name}”.`);
        if (liveError) liveError.textContent = '';
        if (copyMarkupBtn) {
          copyMarkupBtn.disabled = false;
          copyMarkupBtn.textContent = 'Copy';
        }
      } catch (error) {
        console.error('Failed to add live markup to gallery', error);
        setLiveStatus('Save failed');
        if (liveError) liveError.textContent = 'Could not add to gallery. Try again.';
      }
    }

    function handleLiveInput() {
      if (!liveEditor) return;
      const markup = liveEditor.value;
      const trimmed = markup.trim();
      const charCount = markup.length;
      const lineCount = getLineCount(markup);
      updateLineStats();

      if (!trimmed) {
        liveEditor.classList.remove('error');
        liveError.textContent = 'Paste or start typing SVG to render it instantly.';
        setLiveStatus(`Idle • ${charCount} chars • ${lineCount} line${lineCount === 1 ? '' : 's'}`);
        errorLine = null;
        diffLines = [];
        updateHighlights();
        resetLivePreview();
        setAutoSaveStatus('Saved');
        return;
      }

      const analysis = parseSvgMarkup(markup);
      if (!analysis.valid) {
        liveEditor.classList.add('error');
        liveError.textContent = analysis.error;
        errorLine = analysis.line || 1;
        diffLines = [];
        updateHighlights();
        setLiveStatus(`Error • Line ${analysis.line || '?'} • ${charCount} chars`);
        setDiffSummary('Δ fix parsing error');
        setDiffDetails(analysis.error);
        setAutoSaveStatus('Fix errors');
        return;
      }

      liveEditor.classList.remove('error');
      liveError.textContent = '';
      errorLine = null;

      let diff = computeLineDiff(lastRenderedMarkup || '', markup);
      if (!lastRenderedMarkup) {
        diff = { addedCount: 0, removedCount: 0, changedLines: [] };
      }
      diffLines = diff.changedLines;
      updateHighlights();
      updateDiffUI(diff);

      applyLivePreview(markup);
      lastValidMarkup = markup;
      setLiveStatus(`Synced • ${charCount} chars • ${lineCount} line${lineCount === 1 ? '' : 's'}`);
      setAutoSaveStatus('Saving…', true);
      scheduleMarkupSave(markup);
    }

    function enterLiveEdit(markup) {
      if (!liveEditor) return;
      updateEditorMetrics();
      liveEditor.value = markup;
      requestAnimationFrame(() => {
        handleLiveInput();
        updateHighlights();
        liveEditor.focus({ preventScroll: true });
        liveEditor.setSelectionRange(markup.length, markup.length);
      });
    }

    function exitLiveEdit() {
      resetLivePreview();
      setLiveStatus('Idle');
      setDiffDetails('');
      setDiffSummary('Δ 0');
      setAutoSaveStatus('Saved');
      if (liveError) liveError.textContent = '';
      if (liveEditor) {
        liveEditor.value = '';
        diffLines = [];
        errorLine = null;
        updateHighlights();
      }
      if (lineStats) lineStats.textContent = 'Line 1 • Column 1';
      if (copyMarkupBtn) {
        copyMarkupBtn.disabled = false;
        copyMarkupBtn.textContent = 'Copy';
      }
    }

    function setLiveMode(enabled) {
      if (!liveToggle || !liveWorkspace || !galleryWrap) return;
      liveModeEnabled = enabled;
      liveToggle.checked = enabled;
      liveToggle.setAttribute('aria-checked', enabled ? 'true' : 'false');
      persistLivePreference(enabled);
      document.body.classList.toggle('live-mode', enabled);
      galleryWrap.classList.toggle('hide', enabled);
      liveWorkspace.classList.toggle('hide', !enabled);
      liveWorkspace.setAttribute('aria-hidden', enabled ? 'false' : 'true');
      if (drop) drop.classList.toggle('hide', enabled);

      if (enabled) {
        const savedMarkup = (() => {
          try { return localStorage.getItem('svgviewer.liveMarkup') || ''; }
          catch { return ''; }
        })();
        const initialMarkup = savedMarkup.trim() ? savedMarkup : DEFAULT_SVG_SAMPLE;
        lastRenderedMarkup = '';
        lastValidMarkup = initialMarkup;
        enterLiveEdit(initialMarkup);
      } else {
        exitLiveEdit();
      }
    }

    function restoreLiveModePreference() {
      if (!liveToggle) return;
      let stored = null;
      try {
        stored = localStorage.getItem('svgviewer.liveEdit');
      } catch (err) {
        console.warn('Unable to read live edit preference', err);
      }
      const enabled = stored === '1';
      if (enabled) {
        setLiveMode(true);
      } else if (liveToggle) {
        liveToggle.checked = false;
        liveToggle.setAttribute('aria-checked', 'false');
      }
    }
    function openPasteModal(){
      if (!pasteModal) return;
      pasteModal.classList.add('show');
      pasteModal.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';
      if (!svgInput.value) {
        updateSvgInputState();
      }
      focusTextareaSoon();
    }

    function closePasteModal(options = {}){
      if (!pasteModal) return;
      const { restoreFocus = true } = options;
      pasteModal.classList.remove('show');
      pasteModal.setAttribute('aria-hidden', 'true');
      document.body.style.removeProperty('overflow');
      if (restoreFocus && openPasteBtn) {
        openPasteBtn.focus({ preventScroll: true });
      }
    }

    async function addSvgFromMarkup(){
      if (!svgInput) return;
      const markup = svgInput.value.trim();
      let parsed = { valid: true, svg: cachedSvgRoot };

      if (!parsed.svg) {
        parsed = parseSvgMarkup(markup);
      }

      if (!parsed.valid || !parsed.svg) {
        validationBadge.textContent = 'Needs attention';
        validationBadge.classList.add('bad');
        validationBadge.classList.remove('good');
        svgPreview.classList.add('empty');
        svgPreview.innerHTML = '';
        const errorMsg = document.createElement('span');
        errorMsg.textContent = parsed.error;
        svgPreview.appendChild(errorMsg);
        addFromCodeBtn.disabled = true;
        cachedSvgRoot = null;
        return;
      }

      const { name } = await addMarkupToGallery(markup, parsed.svg, { source: 'pasted' });

      svgInput.value = '';
      updateSvgInputState();
      validationBadge.textContent = 'Added to gallery';
      validationBadge.classList.add('good');
      validationBadge.classList.remove('bad');
      svgPreview.innerHTML = '';
      svgPreview.classList.add('empty');
      const successMsg = document.createElement('span');
      successMsg.textContent = `Added "${name}". Paste another to keep the streak going.`;
      svgPreview.appendChild(successMsg);
      cachedSvgRoot = null;
      focusTextareaSoon();
    }

    async function makeCard(file, url){
      const t = document.getElementById('cardTpl');
      const node = t.content.firstElementChild.cloneNode(true);
      node.dataset.name = file.name.toLowerCase();
      node.dataset.size = file.size;

      node.querySelector('.name').textContent = file.name;
      node.querySelector('.sub').textContent = `${fmtBytes(file.size)}`;

      const img = node.querySelector('.thumb');
      img.loading = 'lazy';
      img.decoding = 'async';
      img.src = url;

      const open = node.querySelector('.open');
      open.href = url;
      open.title = 'Open in new tab';

      const dl = node.querySelector('.download');
      dl.href = url;
      dl.download = file.name;

      // Extract colors and apply dynamic theming
      try {
        const colors = await ColorExtractor.extractColors(url);
        const dominantColor = ColorExtractor.getDominantColor(colors);

        if (dominantColor) {
          const colorScheme = ColorExtractor.generateColorScheme(dominantColor);
          applyCardColorScheme(node, colorScheme);
        }
      } catch (error) {
        console.warn('Failed to extract colors for', file.name, error);
      }

      return node;
    }

    function applyCardColorScheme(card, colorScheme) {
      const { primary, accent, complement, subtle } = colorScheme;

      // Apply dynamic CSS custom properties to the card
      card.style.setProperty('--card-accent', primary);
      card.style.setProperty('--card-accent-subtle', subtle);
      card.style.setProperty('--card-complement', complement);

      // Add a subtle accent border
      card.style.borderColor = subtle;

      // Add color indicator dot
      const colorDot = document.createElement('div');
      colorDot.className = 'color-indicator';
      colorDot.style.background = primary;
      card.querySelector('.info').appendChild(colorDot);

      // Enhance buttons with accent colors
      const buttons = card.querySelectorAll('.btn');
      buttons.forEach(btn => {
        btn.addEventListener('mouseenter', () => {
          btn.style.borderColor = accent;
          btn.style.boxShadow = `0 0 12px ${primary}20`;
        });
        btn.addEventListener('mouseleave', () => {
          btn.style.borderColor = '';
          btn.style.boxShadow = '';
        });
      });
    }

    async function addFiles(fileList){
      const arr = Array.from(fileList).filter(f => f.type === 'image/svg+xml' || /\.svg$/i.test(f.name));
      if(!arr.length) return;

      for (const f of arr) {
        const url = URL.createObjectURL(f);
        filesState.push({ name: f.name, size: f.size, url, type: f.type });
        const card = await makeCard(f, url);
        grid.appendChild(card);
      }

      setThumbBg();
      updateMeta();
      applyFilter();
      updateGlobalTheme();
    }

    function clearAll(){
      filesState.forEach(f => URL.revokeObjectURL(f.url));
      filesState = [];
      grid.innerHTML = '';
      updateMeta();
      // Reset global theme
      const root = document.documentElement;
      root.style.removeProperty('--global-accent');
      root.style.removeProperty('--global-subtle');
    }

    function applyFilter(){
      const q = search.value.trim().toLowerCase();
      $$('.card').forEach(card => {
        const name = card.dataset.name;
        card.classList.toggle('hide', q && !name.includes(q));
      });
    }

    function updateGlobalTheme() {
      // Extract dominant colors from all visible cards and create a contextual theme
      const visibleCards = $$('.card:not(.hide)');
      const allColors = [];

      visibleCards.forEach(card => {
        const cardAccent = card.style.getPropertyValue('--card-accent');
        if (cardAccent) allColors.push(cardAccent);
      });

      if (allColors.length > 0) {
        const globalDominant = ColorExtractor.getDominantColor(allColors);
        if (globalDominant) {
          const globalScheme = ColorExtractor.generateColorScheme(globalDominant);
          applyGlobalColorScheme(globalScheme);
        }
      }
    }

    function applyGlobalColorScheme(colorScheme) {
      const { primary, accent, subtle } = colorScheme;
      const root = document.documentElement;

      // Ensure good contrast with background
      const contrastRatio = ColorExtractor.getContrastRatio(primary, '#0b0b0c');
      const adjustedAccent = contrastRatio < 3 ? accent : primary;

      // Apply subtle theming to header and UI elements
      root.style.setProperty('--global-accent', adjustedAccent);
      root.style.setProperty('--global-subtle', subtle);
      root.style.setProperty('--sparkle-primary', adjustedAccent);

      // Update search input border on focus
      const searchInput = $('#search');
      searchInput.addEventListener('focus', () => {
        searchInput.style.borderColor = adjustedAccent;
        searchInput.style.boxShadow = `0 0 0 2px ${adjustedAccent}20`;
      });
      searchInput.addEventListener('blur', () => {
        searchInput.style.borderColor = '';
        searchInput.style.boxShadow = '';
      });

      // Update range inputs
      $$('.range').forEach(range => {
        range.style.accentColor = adjustedAccent;
      });
    }

    // paste modal interactions
    if (openPasteBtn) openPasteBtn.addEventListener('click', () => openPasteModal());
    if (closePasteBtn) closePasteBtn.addEventListener('click', () => closePasteModal());
    if (pasteModal) {
      pasteModal.addEventListener('click', e => {
        if (e.target === pasteModal) closePasteModal();
      });
    }
    if (svgInput) {
      svgInput.addEventListener('input', updateSvgInputState);
      svgInput.addEventListener('paste', () => setTimeout(updateSvgInputState, 0));
      svgInput.addEventListener('keydown', e => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !addFromCodeBtn.disabled) {
          e.preventDefault();
          addSvgFromMarkup();
        }
      });
    }
    if (resetSvgInputBtn) {
      resetSvgInputBtn.addEventListener('click', () => {
        svgInput.value = '';
        updateSvgInputState();
        focusTextareaSoon();
      });
    }
    if (addFromCodeBtn) addFromCodeBtn.addEventListener('click', () => addSvgFromMarkup());

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && pasteModal?.classList.contains('show')) {
        closePasteModal();
      }
    });

    if (liveToggle) {
      liveToggle.addEventListener('change', e => setLiveMode(e.target.checked));
    }
    if (liveEditor) {
      liveEditor.addEventListener('input', handleLiveInput);
      liveEditor.addEventListener('scroll', updateHighlights);
      liveEditor.addEventListener('click', updateLineStats);
      liveEditor.addEventListener('keyup', updateLineStats);
      liveEditor.addEventListener('keydown', () => setTimeout(updateLineStats, 0));
    }
    if (copyMarkupBtn) {
      copyMarkupBtn.addEventListener('click', () => copyLiveMarkup());
    }
    if (addLiveToGalleryBtn) {
      addLiveToGalleryBtn.addEventListener('click', () => addLiveMarkupToGallery());
    }
    window.addEventListener('resize', () => {
      updateEditorMetrics();
      updateHighlights();
    });

    // drag & drop
    ['dragenter','dragover'].forEach(ev=>{
      drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('drag'); });
    });
    ['dragleave','drop'].forEach(ev=>{
      drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.remove('drag'); });
    });
    drop.addEventListener('drop', e => { addFiles(e.dataTransfer.files); });

    // input
    fileInput.addEventListener('change', e => addFiles(e.target.files));

    // controls
    zoom.addEventListener('input', () => {
      setGridControls();
      const zoomValue = document.getElementById('zoomValue');
      if (zoomValue) zoomValue.textContent = zoom.value + 'px';
    });
    gap.addEventListener('input', () => {
      setGridControls();
      const gapValue = document.getElementById('gapValue');
      if (gapValue) gapValue.textContent = gap.value + 'px';
    });
    bgMode.addEventListener('change', setThumbBg);
    clearBtn.addEventListener('click', clearAll);
    search.addEventListener('input', () => {
      applyFilter();
      updateGlobalTheme(); // Update theme when filter changes
    });

    // export list
    exportList.addEventListener('click', () => {
      const rows = filesState.map(f => ({ name: f.name, size_bytes: f.size }));
      const blob = new Blob([JSON.stringify(rows, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'svg-file-list.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 500);
    });

    // init
    setGridControls();
    updateMeta();
    restoreLiveModePreference();
  </script>
</body>
</html>
